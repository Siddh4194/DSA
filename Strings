//Anagrams in the string
//parshally correct
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        int[] num = new int[strs.length];
        for(int i = 0;i < strs.length;i++){
            int sum = 0;
            for(int j = 0;j < strs[i].length(); j++){
                sum += (int)strs[i].charAt(j);
            }
            num[i] = sum;
        }
        List<List<String>> lists = new ArrayList<>();
        HashMap<Integer,List<String>> container = new HashMap<>();
        for(int i = 0 ; i < num.length ; i++){
                container.put(num[i],new ArrayList<String>());
        }
        for(int i = 0 ; i < num.length ; i++){
            container.get(num[i]).add(strs[i]);
        }
        for (HashMap.Entry<Integer, List<String>> entry : container.entrySet()) {
            List<String> value = entry.getValue();
            lists.add(value);
        }
        return lists;
    }
}

Optimized

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        String[] str = new String[strs.length];
        for(int i  = 0 ; i < strs.length; i++){
            char[] temp = strs[i].toCharArray();
            Arrays.sort(temp);
            str[i] = new String(temp);
        }
        HashMap<String,List<String>> container = new HashMap<>();
        List<List<String >> ans = new ArrayList<>();
        for(int i = 0 ; i < str.length ; i++){
            container.put(str[i],new ArrayList<String>());
        }
        for(int i  = 0 ; i < str.length; i++){
            container.get(str[i]).add(strs[i]);
        }
        for(HashMap.Entry<String,List<String>> entry: container.entrySet()){
            List<String> value = entry.getValue();
            ans.add(value);
        }
        return ans;
    }
}

//More optimized solution 

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,List<String>> container = new HashMap<>();
        for(String s : strs){
            char[] temp = s.toCharArray();
            Arrays.sort(temp);
            if(! container.containsKey(new String(temp))){
                container.put(new String(temp) ,new ArrayList<String>());
            }
            container.get(new String(temp)).add(s);
        }
        return new ArrayList<>(container.values());
    }
}
//longest repeating character replacement
// Time Complexity :  O(n)
// Space Complexity : O(1)
//correct
class Solution {
    public int characterReplacement(String s, int k) {
        int[] arr = new int[26];
        int largestCount = 0, left = 0, maxlen = 0;
        for(int right = 0; right < s.length(); right ++){
            arr[s.charAt(right) - 'A']++;
            
            largestCount = Math.max(largestCount, arr[s.charAt(right) - 'A']);
            
            if(right - left + 1 - largestCount > k){     // The main equation is: right - left + 1 - largestCount...
                arr[s.charAt(left) - 'A']--;
                beg ++;
            }
            
            maxlen = Math.max(maxlen, right - left + 1);     
        }
        return maxlen;
    }
}

//parshially correct
class Solution {
    public int check(String s,char a){
        int t = 0 ,max = 0;
        for(int i = 0; i < s.length() ; i++){
            if(s.charAt(i) == a){
                t++;
            } else{
                t = 0;
            }
            max = max > t ? max : t;
        }
        return max;
    }
    public int checkEveryChar(String s , int k,char a){
        int t = k,r = 0,l = 0, maxlength = 0;
        for(int i = 0 ; i < s.length() ;i++){
            if(a != s.charAt(i) && t != 0){
                t--;
            } 
            maxlength = maxlength > (r-l)+1 ? maxlength : (r-l)+1;
            if(t==0 && i != s.length() - 1 && s.charAt(i + 1) != 'A'){
                t = k;
                l = i + 1;
            }
            r++;
        }
        return maxlength;
    }
    public int characterReplacement(String s, int k) {
        Set<Character> uniqueChars = new HashSet<>();
        int max = 0 ;
        for (char c : s.toCharArray()) {
            uniqueChars.add(c);
        }
        for(Character character : uniqueChars){
            if(k == 0){
            return check(s,character);
        }
        int t = checkEveryChar(s,k,character);
        max = max > t ? max : t;
        }
        return max;
    }
}


// level : hard 
// pattern matching sustring
class Solution{
    static boolean match(String wild, String pattern)
    {
        // code here
        // if we go to the end of the string we are done out job
        if(wild.length() == 0 && pattern.length() == 0){
            return true;
        }
        //  remove all consecutive '*'
        if(wild.length() > 1 && wild.charAt(0) == '*'){
            int i = 0;
            while(i + 1 < wild.length() && wild.charAt(i + 1) == '*')
                i++;
            wild = wild.substring(i);
        }
        // there is no '*' present in the string
        if(wild.length() > 1 && wild.charAt(0) == '*' && pattern.length() == 0){
            return false;
        }
        // if the string contain the ?
        if((wild.length() > 1 && wild.charAt(0) == '?') || (wild.length() != 0 && pattern.length() != 0 && wild.charAt(0) == pattern.charAt(0))){
            return match(wild.substring(1),pattern.substring(1));
        }
        
        // if there is star then two posibilities
        if(wild.length() > 0 && wild.charAt(0) == '*'){
            return match(wild.substring(1),pattern) || match(wild,pattern.substring(1));
        }
        return false;
    }
}
